/*
 * Copyright (c) 2019  郑建勋(jonson)
 * License: https://creativecommons.org/licenses/by-nc-sa/4.0/
 * go语言交流3群：713385260
 */

package main
import "fmt"

func main() {
	var a int
	var ptr *int
	var pptr **int

	a = 123

	//	为指针赋值
	ptr = &a
	fmt.Println("ptr:" , ptr)

	//为pptr赋值
	pptr = &ptr
	fmt.Println("pptr" , pptr)

	//获取指针对应的值
	fmt.Printf("变量 a = %d \n" , a)
	fmt.Printf("指针变量 *ptr = %d \n" , *ptr)
	fmt.Printf("指向到指针的变量 **pptr = %d \n" ,**pptr)
}



/*
那么垃Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，
基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。
如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。
同时，局部变量可能在函数返回之后依然存在。
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间
但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。
```
var global *int

func f() {                 func g() {
    var x int                  y := new(int)
    x = 1                      *y = 1
    global = &x            }
}
```
这里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；
用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。
因此，\*y并没有从函数g中逃逸，编译器可以选择在栈上分配\*y的存储空间
（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。
其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。
Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。
你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。
例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。



*/